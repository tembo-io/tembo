// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium -Af -
// kopium version: 0.14.0

use kube::CustomResource;
use schemars::JsonSchema;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;

/// Specification of desired Service selection for target discovery by Prometheus.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "monitoring.coreos.com", version = "v1", kind = "ServiceMonitor", plural = "servicemonitors")]
#[kube(namespaced)]
pub struct ServiceMonitorSpec {
    /// Attaches node metadata to discovered targets. Requires Prometheus v2.37.0 and above.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "attachMetadata")]
    pub attach_metadata: Option<ServiceMonitorAttachMetadata>,
    /// A list of endpoints allowed as part of this ServiceMonitor.
    pub endpoints: Vec<ServiceMonitorEndpoints>,
    /// JobLabel selects the label from the associated Kubernetes service which will be used as the `job` label for all metrics. 
    ///  For example: If in `ServiceMonitor.spec.jobLabel: foo` and in `Service.metadata.labels.foo: bar`, then the `job="bar"` label is added to all metrics. 
    ///  If the value of this field is empty or if the label doesn't exist for the given Service, the `job` label of the metrics defaults to the name of the Kubernetes Service.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "jobLabel")]
    pub job_label: Option<String>,
    /// Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelLimit")]
    pub label_limit: Option<i64>,
    /// Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelNameLengthLimit")]
    pub label_name_length_limit: Option<i64>,
    /// Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelValueLengthLimit")]
    pub label_value_length_limit: Option<i64>,
    /// Selector to select which namespaces the Kubernetes Endpoints objects are discovered from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "namespaceSelector")]
    pub namespace_selector: Option<ServiceMonitorNamespaceSelector>,
    /// PodTargetLabels transfers labels on the Kubernetes `Pod` onto the created metrics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podTargetLabels")]
    pub pod_target_labels: Option<Vec<String>>,
    /// SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sampleLimit")]
    pub sample_limit: Option<i64>,
    /// Selector to select Endpoints objects.
    pub selector: ServiceMonitorSelector,
    /// TargetLabels transfers labels from the Kubernetes `Service` onto the created metrics.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabels")]
    pub target_labels: Option<Vec<String>>,
    /// TargetLimit defines a limit on the number of scraped targets that will be accepted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLimit")]
    pub target_limit: Option<i64>,
}

/// Attaches node metadata to discovered targets. Requires Prometheus v2.37.0 and above.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorAttachMetadata {
    /// When set to true, Prometheus must have permissions to get Nodes.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub node: Option<bool>,
}

/// Endpoint defines a scrapeable endpoint serving Prometheus metrics.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpoints {
    /// Authorization section for this endpoint
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authorization: Option<ServiceMonitorEndpointsAuthorization>,
    /// BasicAuth allow an endpoint to authenticate over basic authentication More info: https://prometheus.io/docs/operating/configuration/#endpoints
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "basicAuth")]
    pub basic_auth: Option<ServiceMonitorEndpointsBasicAuth>,
    /// File to read bearer token for scraping targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenFile")]
    pub bearer_token_file: Option<String>,
    /// Secret to mount to read bearer token for scraping targets. The secret needs to be in the same namespace as the service monitor and accessible by the Prometheus Operator.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bearerTokenSecret")]
    pub bearer_token_secret: Option<ServiceMonitorEndpointsBearerTokenSecret>,
    /// Whether to enable HTTP2.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "enableHttp2")]
    pub enable_http2: Option<bool>,
    /// Drop pods that are not running. (Failed, Succeeded). Enabled by default. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "filterRunning")]
    pub filter_running: Option<bool>,
    /// FollowRedirects configures whether scrape requests follow HTTP 3xx redirects.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "followRedirects")]
    pub follow_redirects: Option<bool>,
    /// HonorLabels chooses the metric's labels on collisions with target labels.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorLabels")]
    pub honor_labels: Option<bool>,
    /// HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "honorTimestamps")]
    pub honor_timestamps: Option<bool>,
    /// Interval at which metrics should be scraped If not specified Prometheus' global scrape interval is used.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interval: Option<String>,
    /// MetricRelabelConfigs to apply to samples before ingestion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "metricRelabelings")]
    pub metric_relabelings: Option<Vec<ServiceMonitorEndpointsMetricRelabelings>>,
    /// OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub oauth2: Option<ServiceMonitorEndpointsOauth2>,
    /// Optional HTTP URL parameters
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<BTreeMap<String, String>>,
    /// HTTP path to scrape for metrics. If empty, Prometheus uses the default value (e.g. `/metrics`).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    /// Name of the service port this endpoint refers to. Mutually exclusive with targetPort.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub port: Option<String>,
    /// ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyUrl")]
    pub proxy_url: Option<String>,
    /// RelabelConfigs to apply to samples before scraping. Prometheus Operator automatically adds relabelings for a few standard Kubernetes fields. The original scrape job's name is available via the `__tmp_prometheus_job_name` label. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub relabelings: Option<Vec<ServiceMonitorEndpointsRelabelings>>,
    /// HTTP scheme to use for scraping.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheme: Option<String>,
    /// Timeout after which the scrape is ended If not specified, the Prometheus global scrape timeout is used unless it is less than `Interval` in which the latter is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scrapeTimeout")]
    pub scrape_timeout: Option<String>,
    /// Name or number of the target port of the Pod behind the Service, the port must be specified with container port property. Mutually exclusive with port.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetPort")]
    pub target_port: Option<String>,
    /// TLS configuration to use when scraping the endpoint
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsConfig")]
    pub tls_config: Option<ServiceMonitorEndpointsTlsConfig>,
}

/// Authorization section for this endpoint
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsAuthorization {
    /// The secret's key that contains the credentials of the request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub credentials: Option<ServiceMonitorEndpointsAuthorizationCredentials>,
    /// Set the authentication type. Defaults to Bearer, Basic will cause an error
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// The secret's key that contains the credentials of the request
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsAuthorizationCredentials {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// BasicAuth allow an endpoint to authenticate over basic authentication More info: https://prometheus.io/docs/operating/configuration/#endpoints
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsBasicAuth {
    /// The secret in the service monitor namespace that contains the password for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub password: Option<ServiceMonitorEndpointsBasicAuthPassword>,
    /// The secret in the service monitor namespace that contains the username for authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub username: Option<ServiceMonitorEndpointsBasicAuthUsername>,
}

/// The secret in the service monitor namespace that contains the password for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsBasicAuthPassword {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret in the service monitor namespace that contains the username for authentication.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsBasicAuthUsername {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret to mount to read bearer token for scraping targets. The secret needs to be in the same namespace as the service monitor and accessible by the Prometheus Operator.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsBearerTokenSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion. It defines `<metric_relabel_configs>`-section of Prometheus configuration. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsMetricRelabelings {
    /// Action to perform based on regex matching. Default is 'replace'. uppercase and lowercase actions require Prometheus >= 2.36.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<ServiceMonitorEndpointsMetricRelabelingsAction>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion. It defines `<metric_relabel_configs>`-section of Prometheus configuration. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceMonitorEndpointsMetricRelabelingsAction {
    #[serde(rename = "replace")]
    Replace,
    #[serde(rename = "keep")]
    Keep,
    #[serde(rename = "drop")]
    Drop,
    #[serde(rename = "hashmod")]
    HashMod,
    #[serde(rename = "labelmap")]
    LabelMap,
    #[serde(rename = "labeldrop")]
    LabelDrop,
    #[serde(rename = "labelkeep")]
    LabelKeep,
    #[serde(rename = "lowercase")]
    Lowercase,
    #[serde(rename = "uppercase")]
    Uppercase,
}

/// OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsOauth2 {
    /// The secret or configmap containing the OAuth2 client id
    #[serde(rename = "clientId")]
    pub client_id: ServiceMonitorEndpointsOauth2ClientId,
    /// The secret containing the OAuth2 client secret
    #[serde(rename = "clientSecret")]
    pub client_secret: ServiceMonitorEndpointsOauth2ClientSecret,
    /// Parameters to append to the token URL
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "endpointParams")]
    pub endpoint_params: Option<BTreeMap<String, String>>,
    /// OAuth2 scopes used for the token request
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scopes: Option<Vec<String>>,
    /// The URL to fetch the token from
    #[serde(rename = "tokenUrl")]
    pub token_url: String,
}

/// The secret or configmap containing the OAuth2 client id
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsOauth2ClientId {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ServiceMonitorEndpointsOauth2ClientIdConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ServiceMonitorEndpointsOauth2ClientIdSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsOauth2ClientIdConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsOauth2ClientIdSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// The secret containing the OAuth2 client secret
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsOauth2ClientSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion. It defines `<metric_relabel_configs>`-section of Prometheus configuration. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsRelabelings {
    /// Action to perform based on regex matching. Default is 'replace'. uppercase and lowercase actions require Prometheus >= 2.36.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub action: Option<ServiceMonitorEndpointsRelabelingsAction>,
    /// Modulus to take of the hash of the source label values.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modulus: Option<i64>,
    /// Regular expression against which the extracted value is matched. Default is '(.*)'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    /// Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available. Default is '$1'
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replacement: Option<String>,
    /// Separator placed between concatenated source label values. default is ';'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
    /// The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceLabels")]
    pub source_labels: Option<Vec<String>>,
    /// Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "targetLabel")]
    pub target_label: Option<String>,
}

/// RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion. It defines `<metric_relabel_configs>`-section of Prometheus configuration. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ServiceMonitorEndpointsRelabelingsAction {
    #[serde(rename = "replace")]
    Replace,
    #[serde(rename = "keep")]
    Keep,
    #[serde(rename = "drop")]
    Drop,
    #[serde(rename = "hashmod")]
    Hashmod,
    #[serde(rename = "labelmap")]
    Labelmap,
    #[serde(rename = "labeldrop")]
    Labeldrop,
    #[serde(rename = "labelkeep")]
    Labelkeep,
    #[serde(rename = "lowercase")]
    Lowercase,
    #[serde(rename = "uppercase")]
    Uppercase,
}

/// TLS configuration to use when scraping the endpoint
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsTlsConfig {
    /// Certificate authority used when verifying server certificates.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ca: Option<ServiceMonitorEndpointsTlsConfigCa>,
    /// Path to the CA cert in the Prometheus container to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caFile")]
    pub ca_file: Option<String>,
    /// Client certificate to present when doing client-authentication.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cert: Option<ServiceMonitorEndpointsTlsConfigCert>,
    /// Path to the client cert file in the Prometheus container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certFile")]
    pub cert_file: Option<String>,
    /// Disable target certificate validation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipVerify")]
    pub insecure_skip_verify: Option<bool>,
    /// Path to the client key file in the Prometheus container for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keyFile")]
    pub key_file: Option<String>,
    /// Secret containing the client key file for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "keySecret")]
    pub key_secret: Option<ServiceMonitorEndpointsTlsConfigKeySecret>,
    /// Used to verify the hostname for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverName")]
    pub server_name: Option<String>,
}

/// Certificate authority used when verifying server certificates.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsTlsConfigCa {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ServiceMonitorEndpointsTlsConfigCaConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ServiceMonitorEndpointsTlsConfigCaSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsTlsConfigCaConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsTlsConfigCaSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Client certificate to present when doing client-authentication.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsTlsConfigCert {
    /// ConfigMap containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMap")]
    pub config_map: Option<ServiceMonitorEndpointsTlsConfigCertConfigMap>,
    /// Secret containing data to use for the targets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub secret: Option<ServiceMonitorEndpointsTlsConfigCertSecret>,
}

/// ConfigMap containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsTlsConfigCertConfigMap {
    /// The key to select.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing data to use for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsTlsConfigCertSecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Secret containing the client key file for the targets.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorEndpointsTlsConfigKeySecret {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selector to select which namespaces the Kubernetes Endpoints objects are discovered from.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorNamespaceSelector {
    /// Boolean describing whether all namespaces are selected in contrast to a list restricting them.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub any: Option<bool>,
    /// List of namespace names to select from.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchNames")]
    pub match_names: Option<Vec<String>>,
}

/// Selector to select Endpoints objects.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<ServiceMonitorSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct ServiceMonitorSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

