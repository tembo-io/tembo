// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium objectstores.barmancloud.cnpg.io -A
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Deserialize, Serialize};
    pub use std::collections::BTreeMap;
}
use self::prelude::*;

/// Specification of the desired behavior of the ObjectStore.
/// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
#[kube(
    group = "barmancloud.cnpg.io",
    version = "v1",
    kind = "ObjectStore",
    plural = "objectstores"
)]
#[kube(namespaced)]
#[kube(status = "ObjectStoreStatus")]
pub struct ObjectStoreSpec {
    /// The configuration for the barman-cloud tool suite
    pub configuration: ObjectStoreConfiguration,
    /// The configuration for the sidecar that runs in the instance pods
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "instanceSidecarConfiguration"
    )]
    pub instance_sidecar_configuration: Option<ObjectStoreInstanceSidecarConfiguration>,
    /// RetentionPolicy is the retention policy to be used for backups
    /// and WALs (i.e. '60d'). The retention policy is expressed in the form
    /// of `XXu` where `XX` is a positive integer and `u` is in `[dwm]` -
    /// days, weeks, months.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retentionPolicy"
    )]
    pub retention_policy: Option<String>,
}

/// The configuration for the barman-cloud tool suite
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreConfiguration {
    /// The credentials to use to upload data to Azure Blob Storage
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "azureCredentials"
    )]
    pub azure_credentials: Option<ObjectStoreConfigurationAzureCredentials>,
    /// The configuration to be used to backup the data files
    /// When not defined, base backups files will be stored uncompressed and may
    /// be unencrypted in the object store, according to the bucket default
    /// policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<ObjectStoreConfigurationData>,
    /// The path where to store the backup (i.e. s3://bucket/path/to/folder)
    /// this path, with different destination folders, will be used for WALs
    /// and for data
    #[serde(rename = "destinationPath")]
    pub destination_path: String,
    /// EndpointCA store the CA bundle of the barman endpoint.
    /// Useful when using self-signed certificates to avoid
    /// errors with certificate issuer and barman-cloud-wal-archive
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "endpointCA"
    )]
    pub endpoint_ca: Option<ObjectStoreConfigurationEndpointCa>,
    /// Endpoint to be used to upload data to the cloud,
    /// overriding the automatic endpoint discovery
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "endpointURL"
    )]
    pub endpoint_url: Option<String>,
    /// The credentials to use to upload data to Google Cloud Storage
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "googleCredentials"
    )]
    pub google_credentials: Option<ObjectStoreConfigurationGoogleCredentials>,
    /// HistoryTags is a list of key value pairs that will be passed to the
    /// Barman --history-tags option.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "historyTags"
    )]
    pub history_tags: Option<BTreeMap<String, String>>,
    /// The credentials to use to upload data to S3
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "s3Credentials"
    )]
    pub s3_credentials: Option<ObjectStoreConfigurationS3Credentials>,
    /// The server name on S3, the cluster name is used if this
    /// parameter is omitted
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serverName"
    )]
    pub server_name: Option<String>,
    /// Tags is a list of key value pairs that will be passed to the
    /// Barman --tags option.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tags: Option<BTreeMap<String, String>>,
    /// The configuration for the backup of the WAL stream.
    /// When not defined, WAL files will be stored uncompressed and may be
    /// unencrypted in the object store, according to the bucket default policy.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub wal: Option<ObjectStoreConfigurationWal>,
}

/// The credentials to use to upload data to Azure Blob Storage
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreConfigurationAzureCredentials {
    /// The connection string to be used
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "connectionString"
    )]
    pub connection_string: Option<ObjectStoreConfigurationAzureCredentialsConnectionString>,
    /// Use the Azure AD based authentication without providing explicitly the keys.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inheritFromAzureAD"
    )]
    pub inherit_from_azure_ad: Option<bool>,
    /// The storage account where to upload data
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageAccount"
    )]
    pub storage_account: Option<ObjectStoreConfigurationAzureCredentialsStorageAccount>,
    /// The storage account key to be used in conjunction
    /// with the storage account name
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageKey"
    )]
    pub storage_key: Option<ObjectStoreConfigurationAzureCredentialsStorageKey>,
    /// A shared-access-signature to be used in conjunction with
    /// the storage account name
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "storageSasToken"
    )]
    pub storage_sas_token: Option<ObjectStoreConfigurationAzureCredentialsStorageSasToken>,
}

/// The connection string to be used
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreConfigurationAzureCredentialsConnectionString {
    /// The key to select
    pub key: String,
    /// Name of the referent.
    pub name: String,
}

/// The storage account where to upload data
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreConfigurationAzureCredentialsStorageAccount {
    /// The key to select
    pub key: String,
    /// Name of the referent.
    pub name: String,
}

/// The storage account key to be used in conjunction
/// with the storage account name
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreConfigurationAzureCredentialsStorageKey {
    /// The key to select
    pub key: String,
    /// Name of the referent.
    pub name: String,
}

/// A shared-access-signature to be used in conjunction with
/// the storage account name
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreConfigurationAzureCredentialsStorageSasToken {
    /// The key to select
    pub key: String,
    /// Name of the referent.
    pub name: String,
}

/// The configuration to be used to backup the data files
/// When not defined, base backups files will be stored uncompressed and may
/// be unencrypted in the object store, according to the bucket default
/// policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreConfigurationData {
    /// AdditionalCommandArgs represents additional arguments that can be appended
    /// to the 'barman-cloud-backup' command-line invocation. These arguments
    /// provide flexibility to customize the backup process further according to
    /// specific requirements or configurations.
    ///
    /// Example:
    /// In a scenario where specialized backup options are required, such as setting
    /// a specific timeout or defining custom behavior, users can use this field
    /// to specify additional command arguments.
    ///
    /// Note:
    /// It's essential to ensure that the provided arguments are valid and supported
    /// by the 'barman-cloud-backup' command, to avoid potential errors or unintended
    /// behavior during execution.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "additionalCommandArgs"
    )]
    pub additional_command_args: Option<Vec<String>>,
    /// Compress a backup file (a tar file per tablespace) while streaming it
    /// to the object store. Available options are empty string (no
    /// compression, default), `gzip`, `bzip2`, and `snappy`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compression: Option<ObjectStoreConfigurationDataCompression>,
    /// Whenever to force the encryption of files (if the bucket is
    /// not already configured for that).
    /// Allowed options are empty string (use the bucket policy, default),
    /// `AES256` and `aws:kms`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encryption: Option<ObjectStoreConfigurationDataEncryption>,
    /// Control whether the I/O workload for the backup initial checkpoint will
    /// be limited, according to the `checkpoint_completion_target` setting on
    /// the PostgreSQL server. If set to true, an immediate checkpoint will be
    /// used, meaning PostgreSQL will complete the checkpoint as soon as
    /// possible. `false` by default.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "immediateCheckpoint"
    )]
    pub immediate_checkpoint: Option<bool>,
    /// The number of parallel jobs to be used to upload the backup, defaults
    /// to 2
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jobs: Option<i32>,
}

/// The configuration to be used to backup the data files
/// When not defined, base backups files will be stored uncompressed and may
/// be unencrypted in the object store, according to the bucket default
/// policy.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ObjectStoreConfigurationDataCompression {
    #[serde(rename = "bzip2")]
    Bzip2,
    #[serde(rename = "gzip")]
    Gzip,
    #[serde(rename = "snappy")]
    Snappy,
}

/// The configuration to be used to backup the data files
/// When not defined, base backups files will be stored uncompressed and may
/// be unencrypted in the object store, according to the bucket default
/// policy.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ObjectStoreConfigurationDataEncryption {
    #[serde(rename = "AES256")]
    Aes256,
    #[serde(rename = "aws:kms")]
    AwsKms,
}

/// EndpointCA store the CA bundle of the barman endpoint.
/// Useful when using self-signed certificates to avoid
/// errors with certificate issuer and barman-cloud-wal-archive
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreConfigurationEndpointCa {
    /// The key to select
    pub key: String,
    /// Name of the referent.
    pub name: String,
}

/// The credentials to use to upload data to Google Cloud Storage
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreConfigurationGoogleCredentials {
    /// The secret containing the Google Cloud Storage JSON file with the credentials
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "applicationCredentials"
    )]
    pub application_credentials:
        Option<ObjectStoreConfigurationGoogleCredentialsApplicationCredentials>,
    /// If set to true, will presume that it's running inside a GKE environment,
    /// default to false.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "gkeEnvironment"
    )]
    pub gke_environment: Option<bool>,
}

/// The secret containing the Google Cloud Storage JSON file with the credentials
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreConfigurationGoogleCredentialsApplicationCredentials {
    /// The key to select
    pub key: String,
    /// Name of the referent.
    pub name: String,
}

/// The credentials to use to upload data to S3
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreConfigurationS3Credentials {
    /// The reference to the access key id
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "accessKeyId"
    )]
    pub access_key_id: Option<ObjectStoreConfigurationS3CredentialsAccessKeyId>,
    /// Use the role based authentication without providing explicitly the keys.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "inheritFromIAMRole"
    )]
    pub inherit_from_iam_role: Option<bool>,
    /// The reference to the secret containing the region name
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub region: Option<ObjectStoreConfigurationS3CredentialsRegion>,
    /// The reference to the secret access key
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretAccessKey"
    )]
    pub secret_access_key: Option<ObjectStoreConfigurationS3CredentialsSecretAccessKey>,
    /// The references to the session key
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "sessionToken"
    )]
    pub session_token: Option<ObjectStoreConfigurationS3CredentialsSessionToken>,
}

/// The reference to the access key id
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreConfigurationS3CredentialsAccessKeyId {
    /// The key to select
    pub key: String,
    /// Name of the referent.
    pub name: String,
}

/// The reference to the secret containing the region name
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreConfigurationS3CredentialsRegion {
    /// The key to select
    pub key: String,
    /// Name of the referent.
    pub name: String,
}

/// The reference to the secret access key
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreConfigurationS3CredentialsSecretAccessKey {
    /// The key to select
    pub key: String,
    /// Name of the referent.
    pub name: String,
}

/// The references to the session key
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreConfigurationS3CredentialsSessionToken {
    /// The key to select
    pub key: String,
    /// Name of the referent.
    pub name: String,
}

/// The configuration for the backup of the WAL stream.
/// When not defined, WAL files will be stored uncompressed and may be
/// unencrypted in the object store, according to the bucket default policy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreConfigurationWal {
    /// Additional arguments that can be appended to the 'barman-cloud-wal-archive'
    /// command-line invocation. These arguments provide flexibility to customize
    /// the WAL archive process further, according to specific requirements or configurations.
    ///
    /// Example:
    /// In a scenario where specialized backup options are required, such as setting
    /// a specific timeout or defining custom behavior, users can use this field
    /// to specify additional command arguments.
    ///
    /// Note:
    /// It's essential to ensure that the provided arguments are valid and supported
    /// by the 'barman-cloud-wal-archive' command, to avoid potential errors or unintended
    /// behavior during execution.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "archiveAdditionalCommandArgs"
    )]
    pub archive_additional_command_args: Option<Vec<String>>,
    /// Compress a WAL file before sending it to the object store. Available
    /// options are empty string (no compression, default), `gzip`, `bzip2`,
    /// `lz4`, `snappy`, `xz`, and `zstd`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub compression: Option<ObjectStoreConfigurationWalCompression>,
    /// Whenever to force the encryption of files (if the bucket is
    /// not already configured for that).
    /// Allowed options are empty string (use the bucket policy, default),
    /// `AES256` and `aws:kms`
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encryption: Option<ObjectStoreConfigurationWalEncryption>,
    /// Number of WAL files to be either archived in parallel (when the
    /// PostgreSQL instance is archiving to a backup object store) or
    /// restored in parallel (when a PostgreSQL standby is fetching WAL
    /// files from a recovery object store). If not specified, WAL files
    /// will be processed one at a time. It accepts a positive integer as a
    /// value - with 1 being the minimum accepted value.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "maxParallel"
    )]
    pub max_parallel: Option<i64>,
    /// Additional arguments that can be appended to the 'barman-cloud-wal-restore'
    /// command-line invocation. These arguments provide flexibility to customize
    /// the WAL restore process further, according to specific requirements or configurations.
    ///
    /// Example:
    /// In a scenario where specialized backup options are required, such as setting
    /// a specific timeout or defining custom behavior, users can use this field
    /// to specify additional command arguments.
    ///
    /// Note:
    /// It's essential to ensure that the provided arguments are valid and supported
    /// by the 'barman-cloud-wal-restore' command, to avoid potential errors or unintended
    /// behavior during execution.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "restoreAdditionalCommandArgs"
    )]
    pub restore_additional_command_args: Option<Vec<String>>,
}

/// The configuration for the backup of the WAL stream.
/// When not defined, WAL files will be stored uncompressed and may be
/// unencrypted in the object store, according to the bucket default policy.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ObjectStoreConfigurationWalCompression {
    #[serde(rename = "bzip2")]
    Bzip2,
    #[serde(rename = "gzip")]
    Gzip,
    #[serde(rename = "lz4")]
    Lz4,
    #[serde(rename = "snappy")]
    Snappy,
    #[serde(rename = "xz")]
    Xz,
    #[serde(rename = "zstd")]
    Zstd,
}

/// The configuration for the backup of the WAL stream.
/// When not defined, WAL files will be stored uncompressed and may be
/// unencrypted in the object store, according to the bucket default policy.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub enum ObjectStoreConfigurationWalEncryption {
    #[serde(rename = "AES256")]
    Aes256,
    #[serde(rename = "aws:kms")]
    AwsKms,
}

/// The configuration for the sidecar that runs in the instance pods
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreInstanceSidecarConfiguration {
    /// The environment to be explicitly passed to the sidecar
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<ObjectStoreInstanceSidecarConfigurationEnv>>,
    /// The retentionCheckInterval defines the frequency at which the
    /// system checks and enforces retention policies.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "retentionPolicyIntervalSeconds"
    )]
    pub retention_policy_interval_seconds: Option<i64>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreInstanceSidecarConfigurationEnv {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<ObjectStoreInstanceSidecarConfigurationEnvValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreInstanceSidecarConfigurationEnvValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "configMapKeyRef"
    )]
    pub config_map_key_ref:
        Option<ObjectStoreInstanceSidecarConfigurationEnvValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<ObjectStoreInstanceSidecarConfigurationEnvValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "resourceFieldRef"
    )]
    pub resource_field_ref:
        Option<ObjectStoreInstanceSidecarConfigurationEnvValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretKeyRef"
    )]
    pub secret_key_ref: Option<ObjectStoreInstanceSidecarConfigurationEnvValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreInstanceSidecarConfigurationEnvValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreInstanceSidecarConfigurationEnvValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "apiVersion"
    )]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreInstanceSidecarConfigurationEnvValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "containerName"
    )]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreInstanceSidecarConfigurationEnvValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Most recently observed status of the ObjectStore. This data may not be up to
/// date. Populated by the system. Read-only.
/// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreStatus {
    /// ServerRecoveryWindow maps each server to its recovery window
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "serverRecoveryWindow"
    )]
    pub server_recovery_window: Option<BTreeMap<String, ObjectStoreStatusServerRecoveryWindow>>,
}

/// ServerRecoveryWindow maps each server to its recovery window
#[derive(Serialize, Deserialize, Clone, Debug, Default, JsonSchema)]
pub struct ObjectStoreStatusServerRecoveryWindow {
    /// The first recoverability point in a PostgreSQL server refers to
    /// the earliest point in time to which the database can be
    /// restored.
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "firstRecoverabilityPoint"
    )]
    pub first_recoverability_point: Option<String>,
    /// The last successful backup time
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lastSuccussfulBackupTime"
    )]
    pub last_succussful_backup_time: Option<String>,
}
